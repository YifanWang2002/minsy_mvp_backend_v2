name: Deploy to GCP VM

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: deploy-main
  cancel-in-progress: true

jobs:
  validate:
    name: Validate Backend
    if: ${{ github.event_name == 'workflow_dispatch' || contains(github.event.head_commit.message, 'Version') }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Import boundary check
        run: python scripts/check_import_boundaries.py

      - name: Python compile check
        run: python -m compileall -q apps packages

  deploy:
    name: Deploy
    if: ${{ github.event_name == 'workflow_dispatch' || contains(github.event.head_commit.message, 'Version') }}
    needs: validate
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          MINSY_DEPLOY_APP_DIR: ${{ secrets.MINSY_DEPLOY_APP_DIR }}
          MINSY_ENV_PROFILE: ${{ secrets.MINSY_ENV_PROFILE }}
          MINSY_COMPOSE_FILE: ${{ secrets.MINSY_COMPOSE_FILE }}
        with:
          host: ${{ secrets.GCP_VM_HOST }}
          username: ${{ secrets.GCP_VM_USER }}
          key: ${{ secrets.GCP_VM_SSH_KEY }}
          port: 22
          script_stop: true
          envs: MINSY_DEPLOY_APP_DIR,MINSY_ENV_PROFILE,MINSY_COMPOSE_FILE
          script: |
            set -eu
            if (set -o pipefail) >/dev/null 2>&1; then
              set -o pipefail
            fi
            export PATH="$HOME/.local/bin:/usr/local/bin:/usr/bin:/bin:$PATH"
            APP_DIR="${MINSY_DEPLOY_APP_DIR:-/home/yifan/minsy_mvp_backend_v2}"
            COMPOSE_FILE="${MINSY_COMPOSE_FILE:-compose.dev.yml}"
            cd "$APP_DIR"

            if [ ! -f "$COMPOSE_FILE" ]; then
              echo "ERROR: compose file not found: $COMPOSE_FILE" >&2
              exit 1
            fi

            COMPOSE_CMD="docker compose -f $COMPOSE_FILE"

            # Match backend runtime env loading order (base + service overlays).
            MINSY_ENV_PROFILE="${MINSY_ENV_PROFILE:-dev}"
            case "$MINSY_ENV_PROFILE" in
              dev|prod) ;;
              *)
                echo "ERROR: MINSY_ENV_PROFILE must be dev or prod (got: $MINSY_ENV_PROFILE)" >&2
                exit 1
                ;;
            esac

            if [ ! -f "env/.env.${MINSY_ENV_PROFILE}" ]; then
              echo "ERROR: missing required profile file env/.env.${MINSY_ENV_PROFILE}" >&2
              exit 1
            fi

            ENV_BASE_LAYERS="
            env/.env.secrets
            env/.env.common
            env/.env.${MINSY_ENV_PROFILE}
            "

            read_env_value() {
              _key="$1"
              _default="${2:-}"
              _service="${3:-}"
              _value=""
              _layers="$ENV_BASE_LAYERS"

              if [ -n "$_service" ]; then
                _layers="${_layers}
            env/.env.${MINSY_ENV_PROFILE}.${_service}
            "
              fi

              for _env_file in $_layers; do
                [ -f "$_env_file" ] || continue
                _line="$(grep -E "^[[:space:]]*${_key}=" "$_env_file" | tail -n1 || true)"
                [ -n "$_line" ] || continue
                _value="${_line#*=}"
              done

              if [ -z "$_value" ]; then
                _value="$_default"
              fi
              printf '%s' "$_value"
            }

            # ── Pre-deploy backup ────────────────────────────────
            echo "=== Pre-deploy backup ==="
            BACKUP_DIR="backups/postgres"
            EXPORT_DIR="exports"
            STAMP=$(date -u +"%Y%m%d_%H%M%S")
            DB_NAME="$(read_env_value POSTGRES_DB minsy_pgsql api)"
            DB_USER="$(read_env_value POSTGRES_USER postgres api)"
            DB_PASS="$(read_env_value POSTGRES_PASSWORD '' api)"

            mkdir -p "$BACKUP_DIR" "$EXPORT_DIR"

            BACKUP_FILE="$BACKUP_DIR/${DB_NAME}_predeploy_${STAMP}.dump"
            if $COMPOSE_CMD ps -q postgres >/dev/null 2>&1; then
              $COMPOSE_CMD exec -T postgres sh -lc \
                "PGPASSWORD='$DB_PASS' pg_dump --format=custom --clean --if-exists --no-owner --no-privileges --username '$DB_USER' --dbname '$DB_NAME'" \
                > "$BACKUP_FILE" \
                && echo "DB backup saved: $BACKUP_FILE ($(stat -c%s "$BACKUP_FILE") bytes)" \
                || echo "WARNING: pg_dump failed, continuing deploy"

              $COMPOSE_CMD exec -T postgres sh -lc \
                "PGPASSWORD='$DB_PASS' psql -U '$DB_USER' -d '$DB_NAME' -t -A -c \"SELECT email FROM users ORDER BY email\"" \
                > "$EXPORT_DIR/user_emails_predeploy_${STAMP}.csv" 2>/dev/null \
                && echo "User emails exported." \
                || echo "WARNING: email export failed, continuing deploy"
            else
              echo "WARNING: postgres service is not running; skip pre-deploy DB backup/export."
            fi

            # Keep only the latest 14 pre-deploy backups
            ls -1t "$BACKUP_DIR"/*_predeploy_*.dump 2>/dev/null | tail -n +15 | xargs -r rm -f || true

            echo "=== Backup complete ==="

            # ── Deploy ───────────────────────────────────────────
            git fetch --prune origin main
            git reset --hard origin/main

            if ! sudo cmp -s /etc/caddy/Caddyfile Caddyfile; then
              sudo install -m 644 Caddyfile /etc/caddy/Caddyfile
              sudo caddy validate --config /etc/caddy/Caddyfile
              sudo systemctl reload caddy
              echo "Caddyfile updated and Caddy reloaded."
            fi

            # Compose-based deploy (single orchestration entrypoint).
            $COMPOSE_CMD up -d --build --remove-orphans

            REQUIRED_SERVICES="postgres redis mcp api worker-cpu worker-io beat"
            for svc in $REQUIRED_SERVICES; do
              if ! $COMPOSE_CMD ps --status running --services | grep -Fxq "$svc"; then
                echo "ERROR: compose service is not running: $svc" >&2
                $COMPOSE_CMD ps
                exit 1
              fi
            done

            dump_service_diagnostics() {
              echo "=== Compose diagnostics ==="
              $COMPOSE_CMD ps || true
              for svc in $REQUIRED_SERVICES; do
                echo "--- compose logs: ${svc} ---"
                $COMPOSE_CMD logs --no-color --tail=120 "$svc" || true
              done
            }

            wait_fastapi_health() {
              _attempt=1
              _max_attempts=30
              while [ "$_attempt" -le "$_max_attempts" ]; do
                if curl -fsS http://127.0.0.1:8000/api/v1/health >/dev/null 2>&1; then
                  echo "FastAPI health check passed."
                  return 0
                fi
                sleep 2
                _attempt=$((_attempt + 1))
              done
              echo "FastAPI did not become ready in time."
              return 1
            }

            wait_mcp_domain() {
              _domain="$1"
              _attempt=1
              _max_attempts=30
              while [ "$_attempt" -le "$_max_attempts" ]; do
                _code="$(curl -s -o /dev/null -w '%{http_code}' "http://127.0.0.1:8110/${_domain}/mcp" || true)"
                if [ "$_code" = "200" ] || [ "$_code" = "406" ]; then
                  echo "MCP domain ${_domain} health check passed (${_code})."
                  return 0
                fi
                sleep 2
                _attempt=$((_attempt + 1))
              done
              echo "MCP domain ${_domain} did not become ready in time (last code: ${_code})."
              return 1
            }

            if ! wait_fastapi_health; then
              dump_service_diagnostics
              exit 1
            fi

            if ! wait_mcp_domain strategy; then dump_service_diagnostics; exit 1; fi
            if ! wait_mcp_domain backtest; then dump_service_diagnostics; exit 1; fi
            if ! wait_mcp_domain market; then dump_service_diagnostics; exit 1; fi
            if ! wait_mcp_domain stress; then dump_service_diagnostics; exit 1; fi
            if ! wait_mcp_domain trading; then dump_service_diagnostics; exit 1; fi

            echo "Deploy success."

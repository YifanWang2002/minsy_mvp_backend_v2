name: Deploy to GCP VM

on:
  push:
    branches: ["main"]

concurrency:
  group: deploy-main
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.GCP_VM_HOST }}
          username: ${{ secrets.GCP_VM_USER }}
          key: ${{ secrets.GCP_VM_SSH_KEY }}
          port: 22
          script_stop: true
          script: |
            set -eu
            if (set -o pipefail) >/dev/null 2>&1; then
              set -o pipefail
            fi
            export PATH="$HOME/.local/bin:/usr/local/bin:/usr/bin:/bin:$PATH"
            APP_DIR="/home/yifan/minsy_mvp_backend_v2"
            cd "$APP_DIR"

            # ── Pre-deploy backup ────────────────────────────────
            echo "=== Pre-deploy backup ==="
            BACKUP_DIR="backups/postgres"
            EXPORT_DIR="exports"
            STAMP=$(date -u +"%Y%m%d_%H%M%S")
            DB_NAME="$(grep -E '^POSTGRES_DB=' .env | tail -n1 | cut -d= -f2- || true)"
            DB_USER="$(grep -E '^POSTGRES_USER=' .env | tail -n1 | cut -d= -f2- || true)"
            DB_HOST="$(grep -E '^POSTGRES_HOST=' .env | tail -n1 | cut -d= -f2- || true)"
            DB_PORT="$(grep -E '^POSTGRES_PORT=' .env | tail -n1 | cut -d= -f2- || true)"
            DB_PASS="$(grep -E '^POSTGRES_PASSWORD=' .env | tail -n1 | cut -d= -f2- || true)"
            DB_NAME="${DB_NAME:-minsy_pgsql}"
            DB_USER="${DB_USER:-postgres}"
            DB_HOST="${DB_HOST:-localhost}"
            DB_PORT="${DB_PORT:-5432}"
            DB_PASS="${DB_PASS:-}"

            mkdir -p "$BACKUP_DIR" "$EXPORT_DIR"

            BACKUP_FILE="$BACKUP_DIR/${DB_NAME}_predeploy_${STAMP}.dump"
            PGPASSWORD="$DB_PASS" pg_dump \
              --format=custom --clean --if-exists --no-owner --no-privileges \
              --host "$DB_HOST" --port "$DB_PORT" \
              --username "$DB_USER" --dbname "$DB_NAME" \
              --file "$BACKUP_FILE" \
              && echo "DB backup saved: $BACKUP_FILE ($(stat -c%s "$BACKUP_FILE") bytes)" \
              || echo "WARNING: pg_dump failed, continuing deploy"

            PGPASSWORD="$DB_PASS" psql \
              -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" \
              -t -A -c "SELECT email FROM users ORDER BY email" \
              > "$EXPORT_DIR/user_emails_predeploy_${STAMP}.csv" 2>/dev/null \
              && echo "User emails exported." \
              || echo "WARNING: email export failed, continuing deploy"

            # Keep only the latest 14 pre-deploy backups
            ls -1t "$BACKUP_DIR"/*_predeploy_*.dump 2>/dev/null | tail -n +15 | xargs -r rm -f || true

            echo "=== Backup complete ==="

            # ── Deploy ───────────────────────────────────────────
            # 备份 .env（不在 git 中管理，reset 后还原）
            ENV_BAK=".env.bak.${STAMP}"
            cp .env "$ENV_BAK"

            # 强制与 main 对齐
            git fetch --prune origin main
            git reset --hard origin/main

            # 还原 .env
            cp "$ENV_BAK" .env
            rm -f "$ENV_BAK"

            # 使用 uv 同步依赖
            uv sync --frozen

            # 同步 Caddyfile 并 reload（仅在变化时，先 validate）
            if ! sudo cmp -s /etc/caddy/Caddyfile Caddyfile; then
              sudo install -m 644 Caddyfile /etc/caddy/Caddyfile
              sudo caddy validate --config /etc/caddy/Caddyfile
              sudo systemctl reload caddy
              echo "Caddyfile updated and Caddy reloaded."
            fi

            # 若 unit 发生变化，确保 systemd 识别
            sudo systemctl daemon-reload

            # 重启应用服务（MCP 拆分后逐个服务）
            SERVICES="minsy-fastapi minsy-mcp-strategy minsy-mcp-backtest minsy-mcp-market minsy-mcp-stress minsy-mcp-trading minsy-celery minsy-celery-beat"

            FLOWER_ENABLED_RAW="$(grep -E '^FLOWER_ENABLED=' .env | tail -n1 | cut -d= -f2- || true)"
            FLOWER_ENABLED_NORM="$(echo "${FLOWER_ENABLED_RAW:-false}" | tr '[:upper:]' '[:lower:]' | xargs)"
            if [ "$FLOWER_ENABLED_NORM" = "1" ] || [ "$FLOWER_ENABLED_NORM" = "true" ] || [ "$FLOWER_ENABLED_NORM" = "yes" ] || [ "$FLOWER_ENABLED_NORM" = "on" ]; then
              SERVICES="$SERVICES minsy-flower"
            fi

            for svc in $SERVICES; do
              sudo systemctl restart "$svc"
            done

            # systemd active 检查
            for svc in $SERVICES; do
              sudo systemctl is-active --quiet "$svc"
            done

            dump_service_diagnostics() {
              echo "=== Service diagnostics ==="
              for svc in $SERVICES; do
                echo "--- systemctl status: ${svc} ---"
                sudo systemctl --no-pager -l status "$svc" || true
                echo "--- journalctl tail: ${svc} ---"
                sudo journalctl -u "$svc" -n 80 --no-pager || true
              done
            }

            wait_fastapi_health() {
              _attempt=1
              _max_attempts=30
              while [ "$_attempt" -le "$_max_attempts" ]; do
                if curl -fsS http://127.0.0.1:8000/api/v1/health >/dev/null 2>&1; then
                  echo "FastAPI health check passed."
                  return 0
                fi
                sleep 2
                _attempt=$((_attempt + 1))
              done
              echo "FastAPI did not become ready in time."
              return 1
            }

            wait_mcp_port() {
              _port="$1"
              _attempt=1
              _max_attempts=30
              while [ "$_attempt" -le "$_max_attempts" ]; do
                _code="$(curl -s -o /dev/null -w '%{http_code}' "http://127.0.0.1:${_port}/mcp" || true)"
                if [ "$_code" = "200" ] || [ "$_code" = "406" ]; then
                  echo "MCP port ${_port} health check passed (${_code})."
                  return 0
                fi
                sleep 2
                _attempt=$((_attempt + 1))
              done
              echo "MCP port ${_port} did not become ready in time (last code: ${_code})."
              return 1
            }

            # 进程健康检查（带重试，避免刚重启时的短暂不可用）
            if ! wait_fastapi_health; then
              dump_service_diagnostics
              exit 1
            fi
            if ! wait_mcp_port 8111; then dump_service_diagnostics; exit 1; fi
            if ! wait_mcp_port 8112; then dump_service_diagnostics; exit 1; fi
            if ! wait_mcp_port 8113; then dump_service_diagnostics; exit 1; fi
            if ! wait_mcp_port 8114; then dump_service_diagnostics; exit 1; fi
            if ! wait_mcp_port 8115; then dump_service_diagnostics; exit 1; fi

            echo "Deploy success."
